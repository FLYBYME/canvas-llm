
import { z } from "zod";



export const ReflectionSchema = z.object({
    styleRules: z
        .array(z.string())
        .describe("The complete new list of style rules and guidelines."),
    content: z
        .array(z.string())
        .describe("The complete new list of memories/facts about the user."),
});

export const REFLECTION_ARTIFACT_PROMPT = `You are also provided with an 'artifact' the user and assistant worked together on to write. Artifacts can be code, creative writing, emails, or any other form of written content.

<artifact>
{artifactContent}
</artifact>`;


export const REFLECT_ARTIFACT_SYSTEM_PROMPT = `You are an expert assistant, and writer. You are tasked with reflecting on the following conversation between a user and an AI assistant.
{artifactPrompt}

You have also previously generated the following reflections about the user. Your reflections are broken down into two categories:
1. Style Guidelines: These are the style guidelines you have generated for the user. Style guidelines can be anything from writing style, to code style, to design style.
  They should be general, and apply to the all the users work, including the conversation and artifact generated.
2. Content: These are general memories, facts, and insights you generate about the user. These can be anything from the users interests, to their goals, to their personality traits.
  Ensure you think carefully about what goes in here, as the assistant will use these when generating future responses or artifacts for the user.
  
<reflections>
{reflections}
</reflections>

Your job is to take all of the context and existing reflections and re-generate all. Use these guidelines when generating the new set of reflections:

<system-guidelines>
- Ensure your reflections are relevant to the conversation and artifact.
- Remove duplicate reflections, or combine multiple reflections into one if they are duplicating content.
- Do not remove reflections unless the conversation/artifact clearly demonstrates they should no longer be included.
  This does NOT mean remove reflections if you see no evidence of them in the conversation/artifact, but instead remove them if the user indicates they are no longer relevant.
- Keep the rules you list high signal-to-noise - don't include unnecessary reflections, but make sure the ones you do add are descriptive.
  This is very important. We do NOT want to confuse the assistant in future interactions by having lots and lots of rules and memories.
- Your reflections should be very descriptive and detailed, ensuring they are clear and will not be misinterpreted.
- Keep the total number of style and user facts low. It's better to have individual rules be more detailed, than to have many rules that are vague.
- Do NOT generate rules off of suspicions. Your rules should be based on cold hard facts from the conversation, and changes to the artifact the user has requested.
  You must be able to provide evidence and sources for each rule you generate if asked, so don't make assumptions.
- Content reflections should be based on the user's messages, not the generated artifacts. Ensure you follow this rule closely to ensure you do not record things generated by the assistant as facts about the user.
</system-guidelines>

I'll reiterate one final time: ensure the reflections you generate are kept at a reasonable length, are descriptive, and are based on the conversation and artifact provided.

Finally, use the 'generate_reflections' tool to generate the new, full list of reflections.`;

export const REFLECT_USER_PROMPT = `Here is my conversation:

{conversation}`;

export const generateReflectionTool = {
    name: "generate_reflections",
    description: "Generate reflections based on the context provided.",
    schema: ReflectionSchema,
};

export default class Reflection {
    constructor() {
        this.reflections = {
            styleRules: [],
            content: [],
        };
    }

    static fromJSON(json) {
        const reflection = new Reflection();
        reflection.reflections = json;
        return reflection;
    }

    toJSON() {
        return this.reflections;
    }

    async generateReflectionsFromConversation(conversation) {
        const model = new ChatOpenAI({
            model: "gpt-4o-mini",
            temperature: 0,
        }).bindTools([generateReflectionTool], {
            tool_choice: "generate_reflections",
        }).withConfig({ runName: "Reflection" });

        const fullSystemPrompt = REFLECT_ARTIFACT_SYSTEM_PROMPT.replace(
            "<artifactPrompt>", ""
        ).replace("<reflections>", conversation.getReflections());

        const fullUserPrompt = REFLECT_USER_PROMPT.replace(
            "{conversation}",
            conversation.getFormattedMessages()
        );

        const messages = [
            { role: "system", content: fullSystemPrompt },
            { role: "user", content: fullUserPrompt },
        ];

        const response = await model.invoke(messages);

        const args = response.tool_calls?.[0]?.args;
        if (!args) {
            throw new Error("No args found in response");
        }

        this.reflections = args;

        return this.reflections;
    }

    async generateReflectionsFromArtifact(artifact, conversation) {
        const model = new ChatOpenAI({
            model: "gpt-4o-mini",
            temperature: 0,
        }).bindTools([generateReflectionTool], {
            tool_choice: "generate_reflections",
        }).withConfig({ runName: "Reflection" });

        const artifactPrompt = REFLECT_ARTIFACT_SYSTEM_PROMPT.replace(
            "<artifactContent>",
            artifact.getFormattedContent()
        );

        const fullSystemPrompt = REFLECT_ARTIFACT_SYSTEM_PROMPT.replace(
            "<artifactPrompt>",
            artifactPrompt
        ).replace("<reflections>", conversation.getReflections());

        const fullUserPrompt = REFLECT_USER_PROMPT.replace(
            "{conversation}",
            conversation.getFormattedMessages()
        );

        const messages = [
            { role: "system", content: fullSystemPrompt },
            { role: "user", content: fullUserPrompt },
        ];

        const response = await model.invoke(messages);

        const args = response.tool_calls?.[0]?.args;
        if (!args) {
            throw new Error("No args found in response");
        }

        this.reflections = args;

        return this.reflections;
    }

    addReflection(reflection) {
        this.reflections.styleRules.push(...reflection.styleRules);
        this.reflections.content.push(...reflection.content);
    }

    getFormattedReflections() {
        return `Style Rules:\n${this.reflections.styleRules.join("\n")}\n\nContent:\n${this.reflections.content.join("\n")}`;
    }
}